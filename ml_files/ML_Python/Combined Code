import cv2
import numpy as np
from ctypes import *
import time

# Setup classifier
face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
eye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml')
phone_cascade = cv2.CascadeClassifier('Mobile_haarcascade.xml')
cap = cv2.VideoCapture(0)

left_counter = 0  # counter for left movement
right_counter = 0  # counter for right movement
c = 0
th_value = 5  # changeable threshold value


def thresholding(value):  # function to threshold and give either left or right
    global left_counter
    global right_counter
    global c

    if (value <= 60):  # check the parameter is less than equal or greater than range to
        left_counter = left_counter + 1  # increment left counter
        if (left_counter > th_value):  # if left counter is greater than threshold value
            print('RIGHT')  # the eye is left
            left_counter = 0  # reset the counter
            c += 1

    elif (value >= 60):  # same procedure for right eye
        right_counter = right_counter + 1

        if (right_counter > th_value):
            print('LEFT')
            right_counter = 0
            c += 1


while True:
    ret, img = cap.read()
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    col = img
    pupilFrame = img
    clahe = img
    blur = img
    edges = img
    # Use classifier to detect faces
    faces = face_cascade.detectMultiScale(gray, 1.3, 5)
    phones = phone_cascade.detectMultiScale(gray, 3, 9)
    for (x, y, w, h) in phones:
        cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 255), 2)
        font = cv2.FONT_HERSHEY_SIMPLEX
        cv2.putText(img, 'Phone', (x - w, y - h), font, 0.5, (11, 255, 255), 2, cv2.LINE_AA)
        #cv2.imwrite("NewPicture.jpg", frame)
        result = False

    for (x, y, w, h) in faces:
        cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 3)
        roi = img[y:y + h, x:x + w]
        roi_gray = gray[y:y + h, x:x + w]
        eyes = eye_cascade.detectMultiScale(roi_gray, 1.3, 5)
        for (ex, ey, ew, eh) in eyes:
            cv2.rectangle(roi, (ex, ey), ((ex + ew), (ey + eh)), (0, 255, 255), 1)
            pupilFrame = cv2.equalizeHist(roi_gray)
            cl1 = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
            clahe = cl1.apply(pupilFrame)  # clahe
            blur = cv2.medianBlur(clahe, 7)  # median blurq
            circles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT, 1, 20, param1=50, param2=30, minRadius=7,
                                       maxRadius=21)  # houghcircles
            if circles is not None:  # if atleast 1 is detected
                circles = np.round(circles[0, :]).astype("int")  # change float to integer
                # print('integer',circles)
                for (ex, ey, r) in circles:
                    cv2.circle(pupilFrame, (ex, ey), r, (0, 255, 255), 2)
                    cv2.rectangle(pupilFrame, (ex - 5, ey - 5), (ex + 5, ey + 5), (0, 128, 255), -1)
                    # set thresholds
                    thresholding(ex)
                    # cv2.rectangle(roi, (ex,ey), (ex+ew, ey+eh), (0,255,0), 2)

    cv2.imshow('img', img)
    if c > 6:
        windll.user32.MessageBoxW(0, "Exam Paused! You have looked away form the screen more than 6 times! ", "ALERT",1)
    if ((cv2.waitKey(30) & 0xff) == 27):
        break

cap.release()
cv2.destroyAllWindows()
